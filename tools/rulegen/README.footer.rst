Example Usage
-------------

These steps walk through the actions required to go from a raw ``.proto`` file to a C++ library. Other languages will have
a similar high-level layout.

**Step 1**: Write a Protocol Buffer .proto file (example: ``thing.proto``):

.. code-block:: proto

   syntax = "proto3";

   package example;

   import "google/protobuf/any.proto";

   message Thing {
       string name = 1;
       google.protobuf.Any payload = 2;
   }

**Step 2**: Write a ``BAZEL.build`` file with a
`proto_library <https://docs.bazel.build/versions/master/be/protocol-buffer.html#proto_library>`_ target:

.. code-block:: starlark

   proto_library(
       name = "thing_proto",
       srcs = ["thing.proto"],
       deps = ["@com_google_protobuf//:any_proto"],
   )

In this example we have a dependency on a well-known type ``any.proto``, hence the ``proto_library`` to ``proto_library``
dependency (``"@com_google_protobuf//:any_proto"``)

**Step 3**: Add a ``cpp_proto_compile`` target

.. note::

   In this example ``thing.proto`` does not include service definitions (gRPC). For protos with services, use the
   ``cpp_grpc_compile`` rule instead.

.. code-block:: starlark

   # BUILD.bazel
   load("@rules_proto_grpc//cpp:defs.bzl", "cpp_proto_compile")

   cpp_proto_compile(
       name = "cpp_thing_proto",
       protos = [":thing_proto"],
   )

But wait, before we can build this, we need to load the dependencies necessary for this rule
(see `cpp/README.md </cpp/README.md>`_):

**Step 4**: Load the workspace macro corresponding to the build rule.

.. code-block:: starlark

   # WORKSPACE
   load("@rules_proto_grpc//cpp:repositories.bzl", "cpp_repos")

   cpp_repos()

We're now ready to build the target.

**Step 5**: Build it!

.. code-block:: bash

   $ bazel build //example/proto:cpp_thing_proto
   Target //example/proto:cpp_thing_proto up-to-date:
     bazel-genfiles/example/proto/cpp_thing_proto/example/proto/thing.pb.h
     bazel-genfiles/example/proto/cpp_thing_proto/example/proto/thing.pb.cc

If we were only interested in the generated files, the ``cpp_grpc_compile`` rule would be fine. However, for
convenience we'd rather have the outputs compiled into a C++ library. To do that, let's change the  rule from
``cpp_proto_compile`` to ``cpp_proto_library``:

.. code-block:: starlark

   # BUILD.bazel
   load("@rules_proto_grpc//cpp:defs.bzl", "cpp_proto_library")

   cpp_proto_library(
       name = "cpp_thing_proto",
       protos = [":thing_proto"],
   )


.. code-block:: bash

   $ bazel build //example/proto:cpp_thing_proto
   Target //example/proto:cpp_thing_proto up-to-date:
     bazel-bin/example/proto/libcpp_thing_proto.a
     bazel-bin/example/proto/libcpp_thing_proto.so  bazel-genfiles/example/proto/cpp_thing_proto/example/proto/thing.pb.h
     bazel-genfiles/example/proto/cpp_thing_proto/example/proto/thing.pb.cc

This way, we can use ``//example/proto:cpp_thing_proto`` as a dependency of any other ``cc_library`` or ``cc_binary`` target
as per normal.

.. note::

   NOTE: The ``cpp_proto_library`` target implicitly calls ``cpp_proto_compile``, and we can access that rule's by adding
   ``_pb`` at the end of the target name, like ``bazel build //example/proto:cpp_thing_proto_pb``


Developers
----------

Code Layout
***********

Each language ``{lang}`` has a top-level subdirectory that contains:

1. ``{lang}/README.md``: Generated documentation for the language rules

1. ``{lang}/repositories.bzl``: Macro functions that declare repository rule dependencies for that language

2. ``{lang}/{rule}.bzl``: Rule implementations of the form ``{lang}_{kind}_{type}``, where ``kind`` is one of ``proto|grpc`` and
   ``type`` is one of ``compile|library``

3. ``{lang}/BUILD.bazel``: ``proto_plugin()`` declarations for the available plugins for the language

4. ``example/{lang}/{rule}/``: Generated ``WORKSPACE`` and ``BUILD.bazel`` demonstrating standalone usage of the rules

5. ``{lang}/example/routeguide/``: Example routeguide example implementation, if possible


Rule Generation
***************

To help maintain consistency of the rule implementations and documentation, all of the rule implementations are
generated by the tool ``//tools/rulegen``. Changes in the main ``README.md`` should be placed in
``tools/rulegen/README.header.rst`` or ``tools/rulegen/README.footer.rst```. Changes to generated rules should be put in the
source files (example: ``tools/rulegen/java.go``).


Developing Custom Plugins
*************************

Generally, follow the pattern seen in the multiple language examples in this
repository.  The basic idea is:

1. Load the plugin rule: ``load("@rules_proto_grpc//:defs.bzl", "proto_plugin")``
2. Define the rule, giving it a ``name``, ``options`` (not mandatory), ``tool`` and ``outputs``. ``tool`` is a label that refers
   to the binary executable for the plugin itself
3. Choose your output type (pick one!):
    - ``outputs``: A list of strings patterns that predicts the pattern of files generated by the plugin. For plugins that
      produce one output file per input proto file
    - ``out``: The name of a single output file generated by the plugin
    - ``output_directory``: Set to true if your plugin generates files in a non-predictable way. e.g. if the output paths
      depend on the service names within the files
4. Create a compilation rule and aspect using the following template:

.. code-block:: starlark

   load("@rules_proto//proto:defs.bzl", "ProtoInfo")
   load(
       "@rules_proto_grpc//:defs.bzl",
       "ProtoLibraryAspectNodeInfo",
       "ProtoPluginInfo",
       "proto_compile_aspect_attrs",
       "proto_compile_aspect_impl",
       "proto_compile_attrs",
       "proto_compile_impl",
   )

   # Create aspect
   example_aspect = aspect(
       implementation = proto_compile_aspect_impl,
       provides = [ProtoLibraryAspectNodeInfo],
       attr_aspects = ["deps"],
       attrs = dict(
           proto_compile_aspect_attrs,
           _plugins = attr.label_list(
               doc = "List of protoc plugins to apply",
               providers = [ProtoPluginInfo],
               default = [
                   Label("//<LABEL OF YOUR PLUGIN>"),
               ],
           ),
           _prefix = attr.string(
               doc = "String used to disambiguate aspects when generating outputs",
               default = "example_aspect",
           ),
       ),
       toolchains = ["@rules_proto_grpc//protobuf:toolchain_type"],
   )

   # Create compile rule to apply aspect
   _rule = rule(
       implementation = proto_compile_impl,
       attrs = dict(
           proto_compile_attrs,
           protos = attr.label_list(
               mandatory = False,  # TODO: set to true in 4.0.0 when deps removed below
               providers = [ProtoInfo],
               doc = "List of labels that provide the ProtoInfo provider (such as proto_library from rules_proto)",
           ),
           deps = attr.label_list(
               mandatory = False,
               providers = [ProtoInfo, ProtoLibraryAspectNodeInfo],
               aspects = [example_aspect],
               doc = "DEPRECATED: Use protos attr",
           ),
           _plugins = attr.label_list(
               providers = [ProtoPluginInfo],
               default = [
                   Label("//<LABEL OF YOUR PLUGIN>"),
               ],
               doc = "List of protoc plugins to apply",
           ),
       ),
       toolchains = [str(Label("//protobuf:toolchain_type"))],
   )

   # Create macro for converting attrs and passing to compile
   def example_compile(**kwargs):
       _rule(
           verbose_string = "{}".format(kwargs.get("verbose", 0)),
           **kwargs
       )


License
-------

This project is derived from `stackb/rules_proto <https://github.com/stackb/rules_proto>`_ under the
`Apache 2.0 <http://www.apache.org/licenses/LICENSE-2.0>`_ license and  this project therefore maintains the terms of that
license
