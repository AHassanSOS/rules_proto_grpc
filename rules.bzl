ProtoPluginInfo = provider(fields = {
    "name": "proto plugin name",
    "outputs": "outputs to be generated",
    "tool": "plugin tool",
    "options": "proto options",
})

ProtoCompileInfo = provider(fields = {
    "plugins": "ProtoPluginInfo object",
    "grpc_plugins": "ProtoPluginInfo object",
    "descriptor": "descriptor set file",
    "outputs": "generated outputs",
    "protos": "generated protos (copies)",
    "args": "proto arguments",
    "tools": "proto tools",
})


def _proto_plugin_impl(ctx):
    return [ProtoPluginInfo(
        name = ctx.label.name,
        options = ctx.attr.options,
        outputs = ctx.attr.outputs,
        tool = ctx.executable.tool,
    )]

proto_plugin = rule(
    implementation = _proto_plugin_impl,
    attrs = {
        "options": attr.string(
            doc = "An option string to pass to the compiler.",
        ),
        "outputs": attr.string_list(
            doc = "The file extension generated by output files.  Example: '{basename}_pb2.py'",
            mandatory = True,
        ),
        "tool": attr.label(
            doc = "The plugin binary.  If absent, assume the plugin is a built-in to protoc itself",
            cfg = "host",
            executable = True,
        ),
    }
)


# Hack - providers indexing is by int, but I have not idea how to get the actual
# provider object here.
ProtoInfoProvider = 0

def _get_output_filename(src, pattern):
    basename = src.basename
    if basename.endswith(".proto"):
        basename = basename[:-6]
    elif basename.endswith(".protodevel"):
        basename = basename[:-11]
    if pattern.find("{basename}") != -1:
        return pattern.replace("{basename}", basename)
    else:
        return basename + pattern
    # TODO implement more renaming styles


def _get_proto_filename(src):
    #print("src.short_path: %s" % src.short_path)
    parts = src.short_path.split("/")
    if len(parts) > 1 and parts[0] == "..":
        return "/".join(parts[2:])
    return src.short_path

def copy_proto(ctx, descriptor, src):
    proto = ctx.actions.declare_file(_get_proto_filename(src), sibling = descriptor)
    ctx.actions.run_shell(
        mnemonic = "CopyProto",
        inputs = [src],
        outputs = [proto],
        command = "cp %s %s" % (src.path, proto.path),
    )
    return proto


proto_compile_attrs = {
    "deps": attr.label_list(
        mandatory = True,
        providers = ["proto"],
    ),
    "plugins": attr.label_list(
        providers = [ProtoPluginInfo],
        mandatory = True,
    ),
    "grpc_plugins": attr.label_list(
        providers = [ProtoPluginInfo],
        mandatory = False,
    ),
    "has_services": attr.bool(
        doc = "If the proto files(s) have a service rpc, generate grpc outputs",
    ),
    "protoc": attr.label(
        default = "@com_google_protobuf//:protoc",
        cfg = "host",
        executable = True,
    ),
}

proto_compile_outputs = {
    "descriptor": "%{name}/descriptor.bin",
}

def proto_compile_impl(ctx):
    protoc = ctx.executable.protoc
    descriptor = ctx.outputs.descriptor
    has_services = ctx.attr.has_services

    deps = [dep.proto for dep in ctx.attr.deps]
    plugins = [plugin[ProtoPluginInfo] for plugin in ctx.attr.plugins]
    grpc_plugins = [plugin[ProtoPluginInfo] for plugin in ctx.attr.grpc_plugins]
    tools = [protoc]
    protos = []
    outputs = []
    args = []
    directs = {}

    for dep in deps:
        for src in dep.direct_sources:
            if directs.get(src.path):
                continue
            directs[src.path] = src
            proto = copy_proto(ctx, descriptor, src)
            protos.append(proto)

            for plugin in plugins:
                for output in plugin.outputs:
                    outputs.append(ctx.actions.declare_file(_get_output_filename(src, output), sibling = proto))

            if has_services:
                for plugin in grpc_plugins:
                    for output in plugin.outputs:
                        outputs.append(ctx.actions.declare_file(_get_output_filename(src, output), sibling = proto))

        for src in dep.transitive_sources:
            if directs.get(src.path):
                continue
            #print("transitive source: %r" % src)
            proto = copy_proto(ctx, descriptor, src)
            protos.append(proto)
        for e in dep.transitive_proto_path:
            print("proto_path: %r" % e)
        # for e in dep.transitive_descriptor_sets:
        #     print("descriptor_set: %r" % e)

    args += ["--descriptor_set_out=%s" % descriptor.path]
    args += ["--proto_path=%s" % descriptor.dirname]        
    for plugin in plugins:
        args += ["--%s_out=%s" % (plugin.name, descriptor.dirname)]        
    if has_services:
        for plugin in grpc_plugins:
            args += ["--%s_out=%s" % (plugin.name, descriptor.dirname)]    
            if plugin.tool:    
                args += ["--plugin=protoc-gen-%s=%s" % (plugin.name, plugin.tool.path)]        
                tools += [plugin.tool]

    args += [proto.path for proto in protos]

    ctx.actions.run_shell(
        command = "find . && " +  " ".join([protoc.path] + args) + " && find .",
        #command = " ".join([protoc.path] + args),
        inputs = tools + protos,
        outputs = outputs + [descriptor],
    )

    return [ProtoCompileInfo(
        plugins = plugins,
        grpc_plugins = grpc_plugins,
        protos = protos,
        outputs = outputs,
        tools = tools,
        args = args,
        descriptor = descriptor,
    ), DefaultInfo(files = depset(outputs))]

proto_compile = rule(
    implementation = proto_compile_impl,
    attrs = proto_compile_attrs,
    outputs = proto_compile_outputs,
    output_to_genfiles = True,
)